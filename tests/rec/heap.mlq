measure set_of =
    Empty -> Myaset.empty
  | Same (x, l, r) -> Myaset.cup (Myaset.sng x) (Myaset.cup (set_of l) (set_of r))
  | Diff (x, l, r) -> Myaset.cup (Myaset.sng x) (Myaset.cup (set_of l) (set_of r))
measure sz =
    Empty -> 0
  | Same (x, l, r) -> 1 + sz l + sz r
  | Diff (x, l, r) -> 1 + sz l + sz r
measure max =
  | Same (x, _, _) -> x
  | Diff (x, _, _) -> x
val empty: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}]
val add: x: 'a -> h: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] -> {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (? Myaset.eq (set_of v) (Myaset.cup (set_of h) (Myaset.sng x))) and ((sz v) = (sz h) + 1)}
val maximum: h: {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (sz v) > 0} -> 'a * {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || d: 'a, e1: [[], [v: v <= d and v <= e0, v: true, v: true], [v: v <= d and v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= d and v <= e0, v: true, v: true], [v: v <= d and v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || d: 'a, e1: [[], [v: v <= d and v <= e0, v: true, v: true], [v: v <= d and v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= d and v <= e0, v: true, v: true], [v: v <= d and v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (((? Myaset.mem e0 (set_of v))) and v = h) and e0 = (max v)}
val extract_last: h: {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (sz v) > 0} -> {v: 'a | ((sz h) = 1 -> v = (max h))} * {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | ((? Myaset.eq (set_of h) (Myaset.cup (set_of v) (Myaset.sng e0))) and (sz v) = (sz h) - 1) and ((sz h) > 1 -> (max h) = (max v))}
val descent: x: 'a -> h: {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (sz v) > 0} -> {v: 'a | (? Myaset.mem v (set_of h)) and v = (max h)} * {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | ((? Myaset.eq (Myaset.cup (set_of h) (Myaset.sng x)) (Myaset.cup (set_of v) (Myaset.sng e0))) and (? Myaset.mem x (set_of v))) and ((sz v) = (sz h))}
val remove: h: {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (sz v) > 0} -> {v: 'a | (? Myaset.mem v (set_of h)) and v = (max h)} * {v: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] | (sz v) = (sz h) - 1 and (? Myaset.eq (set_of h) (Myaset.cup (Myaset.sng e0) (set_of v)))}
val iter: f: ('a -> 'b) -> h: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] -> unit
val fold: f: ('a -> 'b -> 'b) -> h: [[], [v: true, v: true, v: true], [v: true, v: true, v: true]] [z: t . || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2))} || e0: 'a, e1: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z, {e2: [[], [v: v <= e0, v: true, v: true], [v: v <= e0, v: true, v: true]] z | ((sz e1) = (sz e2) + 1)}] -> b: 'b -> 'b


axiom pos : forall (x: int. sz x >= 0)
