Compiling dsolve
================

dsolve requires OCaml 3.10+.

To compile dsolve:

1. Download yices from http://yices.csl.sri.com/download.shtml
   (NOTE: Be sure to download the version with GMP dynamically linked!)

2. Untar yices with:

     tar zxvf [path to yices tar] --strip-components=1 -C external/yices

3. Run ./configure && make libs && make

Running dsolve
==============

To typecheck your program with dsolve, simply run:

  ./dsolve.py [ML source file]

Example programs are included in tests/.
The inferred types are output in a .annot file.
For example:

  ./dsolve.py foo.ml

Will produce an annotation file foo.annot

Sometimes the types have predicates like "(= V (+ __tmp0 1))".  This is due to
A-normalization.  To get around this, you can run without A-normalization:

  ./dsolve.py -no-anormal [ML source file]

Many programs will not typecheck without A-normalization, so it is on
by default.

For more options, run:

  ./dsolve.py -help

Defining Qualifiers
===================

When dsolve is invoked on a file path_to/foo.ml, it reads uses the qualifiers
specified in the file:

  ./default_patterns

as well as the qualifiers specified in the file

  path_to/foo.hquals

if the latter exists.

Qualifiers look like this:

  qualif CapitalizedName(x): x <= 10

[TODO]
Here are further examples of the qualifier syntax:

^ - integer literal wildcard
* * - relational/operator wildcard

metavariables and type annotations

qualif A(v) : ~A + v = 5
qualif C(v)(A:int, B:int) : ~A + v + ~B = 5

sets of integer literals

qualif A(v): v = [0,1,2]

sets of idents

qualif A(v) : v = [a, b, c]

sets of operators

qualif A(v) : v [| +, - |] 5 > 0

sets of relational operators

qualif A(v): v { <, <= } 5

to an operator wildcard is DELIM * * DELIM eg, [| * * |] for any operator

- annotated types are matched to program types 
  by attempting to unify, not structurally

- pattern names are lost after expansion 

unhandled types: the type grammar can't handle ADTs or records. 
However, you can define these as user types in the program source 
and then reference the type name in the pattern *)
[END TODO note still TODO]

Defining Liquid Interfaces 
==========================

USAGE: a .mlq file should be placed in the same directory 
as the source file. If not found, the typechecker will 
not use it, and will do so silently.

SYNTAX:

a .mlq is two lists: first, a list of predicate aliases, 
and second a list of val, type pairs.

*** Predicate aliases:

pred P = (v) v > 0

the (v) is the bound variable.

*** Val to liquid type bindings:

val program_ident : {v: int | v > 0 }

the type on the right hand side of the colon can take on several forms:

int == {int | true}

{v: int array | Array.length v > 0} == {v: {int | true} array | Array.length v > 0)

{int | P} == {v: int | v > 0} ** NOTE: predicate aliases can't be nested

records:

{v: { lbl : int } | v.lbl = 0} == {v: { lbl : {int | true} | v.lbl = 0}

tuples work similarly, as do type vars, which can be refined, 
but whose refinements won't carry through.

Simple ADTs (meaning 'a list) will also work, but disjoint 
unions/variants/etc. will NOT work.

ERROR MESSAGES:

-liquid interface files which contain idents not found in 
the program will fail with an explicit error. Files which 
contain types which don't unify with the program shapes 
will fail with a cryptic error* about types not being 
supported in instantiation:

Unsupported types for instantiation: {({bool | true}, {int | true}) | true}
  {int | k_1191}
Fatal error: exception Assert_failure("qualifying/frame.ml", 168, 5)
*other cryptic errors may apply

If your type annotation causes the program to not typecheck, 
the error message will have an inexplicable location:

File "DML/bsearch.mlq", line 1, characters 0-1:
{int | (V = __atmp30)} is not a subtype of {int | (v >= 0)}
