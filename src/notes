An issue with EQX(y): y = x
---------------------------

It doesn't friggin' work.  In particular, we're going to get something like this:
(fun x -> fun y -> y) 3 3;;
[] <: [x -> 3] a	(y -> 3)
[] <: b			(x -> 3)

Final type is [x -> 3; y -> 3] a.  What're we missing?  That a is the type of y?
One possible solution is to throw in a qualifier that describes y in terms of x.
Then we'll have the first constraint as
[] something about y <: [x -> ...] a
Note we'd actually probably want a pair of qualifiers that describe x and y, then
a third qual that describes the relationship.  But this would require us to say
something about x in the environment at application time, which is annoying...
