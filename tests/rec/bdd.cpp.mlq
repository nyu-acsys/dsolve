#define BND(v)  {v: int | (0 <= v) and (v < 1000)}
#define RR      [[v:true],[v:true],[v:true,v:true,v:true,v:true]]
#define SUB(v)  {v:RR z | (e1 < var v) and (var v <= 1000)}
#define BDD     RR [z: bdd. e0: int || e0:int || e0: int, BND(e1), SUB(e2), SUB(e3)]
#define TT(p)   {v:BDD | (0 <= var v and var v <= 1000) and (p) }    
#define VART 	BND(v)

measure var =
  | Zero _		-> 1000 
  | One  _		-> 1000 
  | Node (_,v,_,_)	-> v

val skip  : TT(true) -> unit

val mk	  : x: BND(v) -> TT(x < var v) -> TT(x < var v) -> TT(x <= var v)
val mk_var: x: BND(v) -> TT(true)
(* val mk_not: x: TT(true) -> TT(var x <= var v) *)
val gapply: operator -> x:TT(true) -> y:TT(true) -> TT((var x <= var v) or (var y <= var v))
val mk_not: x: TT(true) -> TT(true)
val mk_and : TT(true) -> TT(true) -> TT(true)
val mk_or  : TT(true) -> TT(true) -> TT(true)
val mk_imp : TT(true) -> TT(true) -> TT(true)
val mk_iff : TT(true) -> TT(true) -> TT(true)
val apply : (bool -> bool -> bool) -> TT(true) -> TT(true) -> TT(true)

(*
val var : t -> int
val low : t -> t
val high: t -> t
val zero: t
val one : t
val mk : int -> low:t -> high:t -> t
val mk_var : int -> t
val mk_not : t -> t
val build : formula -> t
*)
(*
type t
type view = Zero | One | Node of int * t (*low*) * t (*high*)
*)
