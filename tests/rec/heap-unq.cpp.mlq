#define S(v)   (sz v)
#define SAME(v, h) (S(v) = S(h))
#define DIFF(l, r) (S(l) = S(r) + 1)

#define M(v)   (max v)

#define R(p)   [[], [v: p, v: true, v: true], [v: p, v: true, v: true]]
#define UR     R(true)
#define SR     R(v < e0)
#define BR(b)  R(v < d and v < b)
#define HP     UR [z: t . || e0: 'a, e1: SR z, {e2: SR z | SAME(e1, e2)} || e0: 'a, e1: SR z, {e2: SR z | DIFF(e1, e2)}]
#define BHP(b) UR [z: t . || d: 'a, e1: BR(b) z, {e2: BR(b) z | SAME(e1, e2)} || d: 'a, e1: BR(b) z, {e2: BR(b) z | DIFF(e1, e2)}]
#define DHP(b)     UR [z: t . || {e0: 'a | e0 != b}, e1: SR z, {e2: SR z | SAME(e1, e2)} || {e0: 'a | e0 != b}, e1: SR z, {e2: SR z | DIFF(e1, e2)}]

axiom pos: forall (x: int. S(x) >= 0)

measure sz =
  | Empty -> 0
  | Same (x, l, r) -> 1 + sz l + sz r
  | Diff (x, l, r) -> 1 + sz l + sz r

measure max =
  | Same (x, _, _) -> x
  | Diff (x, _, _) -> x

val empty: HP

val add: x: 'a -> h: DHP(x) -> {v: HP | S(v) = S(h) + 1}
val maximum: h: {v: HP | S(v) > 0}  -> 'a * {v: BHP(e0) | e0 = M(v) and h = v}
val extract_last: h: {v: HP | S(v) > 0} -> 'a * {v: HP | S(v) = S(h) - 1}
val descent: x: 'a -> h: {v: DHP(x) | S(v) > 0} -> {v: 'a | v = M(h)} * {v: HP | SAME(v, h)}
(*val remove: h: HP -> HP
val iter: f: ('a -> 'b) -> h: HP -> unit
val fold: f: ('a -> 'b -> 'b) -> h: HP -> b: 'b -> 'b*)
