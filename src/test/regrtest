#!/bin/bash
# this has to be /bin/bash, because of $[ 1+2 ] syntax
# some simple cil regression tests; ideally, everyone can run
# this before committing
# ---------------------------------------------------------
# Adapted from a shell script used in Cil
# default values for user parameters
skip=0
contin=0
perf=0
tool="time ../foci.opt"
block=""
log=regrtest.log
stat=regrtest.stat
itpfile=itp.out

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
dies=0

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -perf)
      perf=1
      ;;

    -contin)
      contin=1
      ;;

    -extra)       
      shift
      tool="$tool $1"
      ;;

    -help)
      usage
      exit 0
      ;;

    -block)
      shift
      block="$block$1"
     ;;
     
    -all)
     block="ALL"
     ;;
     
    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac
  shift
done

# clear the logfiles
rm -f *.log # we clear all logfiles from individual tests as well
rm -f regrtest.stat

#RJ: I don't really follow the deal with contin...
# process args

usage() {
cat <<EOF
usage: $0 [options]
  -skip n      skip the first n tests
  -perf	       do performance evaluation
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -extra str   add "str" to every tool command
  -help        print this message
  -block s     run the tests in block s (default "all")
  -all         run all the tests
EOF
}

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $log
}

#takes  no args -- just does a bunch of greps on the test_*.log file
getstats() {
echo "getting stats"
#echo "[$curtest]" >> $stat 
echo `grep "TOTAL" test_${curtest}_full.log` >> $stat
echo "" >> $stat
}


# bail, unless asked to continue
bail() {
  if [ $contin -eq 0 ]; then
    exit 2
  fi
}

# run a single test, and bail if it fails
#runTest() {
#  if ! runTestInternal "$@"; then
#    bail
#  fi
#}

# returns 0 if foci says SAT or Undecided, 1 otherwise.
isSat(){
  res=0
  echo "in isSat"
  echo "isSat returns: [$res]"
  if grep "Undecided" test_${curtest}_full.log; then
    res=1
  fi
  if grep "SAT" test_${curtest}_full.log; then
    res=1
  fi
  return $res
}

# returns 1 if foci says UNSAT (and so, generates ITP)
isUnsat(){
  res=0
  if grep "CONTRA" test_${curtest}_full.log; then
    res=1
  fi
  return $res
}

# run a single test, and return 0 if it succeeds
#runTestInternal() {
runTest(){
  #result=0
  rm -f test_${curtest}*.log
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    "$@" > test_${curtest}_full.log 2>&1
    #result=$?
    if grep "Undecided" test_${curtest}_full.log || grep "SAT" test_${curtest}_full.log; then 
      unexFailure=$[ $unexFailure + 1 ]
      echo ""
      log  "[$curtest] A regression test command failed: cannot prove UNSAT"
      log  "  $*"
      tail -200 test_${curtest}_full.log >test_${curtest}.log
      rm test_${curtest}_full.log
    else
      if grep "CONTRA" test_${curtest}_full.log ; then
	log "[$curtest] $@ succeeds"
        success=$[ $success + 1 ]
	getstats
	rm test_${curtest}_full.log
        if [ "$perf" -eq 1 ]; then 
          echo "Now running performace tests"
          rm -f tmp
#          for n in 1 2 3 4 5; do
          for n in 1 ; do
            if (time "$@" >test_${curtest}_${n}.log 2>&1) 2>times.out; then
              cat times.out | grep real | sed 's/real	0m/    /' \
                        | sed 's/s$//' | tee -a tmp
              rm times.out test_${curtest}_${n}.log
            else
              echo "Run $n of $@ failed."
              exit 4
            fi
         done
            # games with awk are to make sure sorting happens properly even when
            # the input times don't all have same # of digits (e.g. 9s vs 10s)
         log "    median:"`awk '{ printf("%9.3fs\n", $1); }' <tmp | sort | head -3 | tail -1`
         rm tmp
        fi
      else
        echo ""
	log "[$curtest] $@ Unexpected error"
	tail -200 test_${curtest}_full.log >test_${curtest}.log
	rm test_${curtest}_full.log
	dies=$[ $dies + 1]
      fi
    fi
  fi
  curtest=$[ $curtest + 1 ]
  return $result
}


# run a test that is expected to fail
failTest() {
  reason="$1"
  shift
  rm -f test_${curtest}*.log
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    "$@" > test_${curtest}_full.log 2>&1
    if grep "CONTRA" test_${curtest}_full.log; then
      unexSuccess=$[ $unexSuccess + 1 ]
      echo ""
      log  "[$curtest] BAD NEWS: A regression test that is SAT ($reason) is reported UNSAT:"
      log  "  $*"
      tail -200 test_${curtest}_full.log >test_${curtest}.log
      rm test_${curtest}_full.log
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      if grep "Undecided" test_${curtest}_full.log || grep "SAT" test_${curtest}_full.log; then 
        failure=$[ $failure + 1 ]
        echo "SAT as expected: $reason"
	log "[$curtest] $@ fails as expected"
	getstats
        rm -f test_${curtest}_full.log

        if [ "$perf" -eq 1 ]; then 
          echo "Now running performance tests"
          rm -f tmp
          for n in 1 2 3 4 5; do
            if (time "$@" >test_${curtest}_${n}.log 2>&1) 2>times.out; then
              cat times.out | grep real | sed 's/real	0m/    /' \
                        | sed 's/s$//' | tee -a tmp
              rm times.out test_${curtest}_${n}.log
            else
              echo "Run $n of $@ failed."
              exit 4
            fi
         done

            # games with awk are to make sure sorting happens properly even when
            # the input times don't all have same # of digits (e.g. 9s vs 10s)
         log "    median:"`awk '{ printf("%9.3fs\n", $1); }' <tmp | sort | head -3 | tail -1`
         rm tmp
        fi
      else
        echo "[$curtest] A regression test command failed: Unexpected error"
        log "[$curtest] $@ Unexpected error"
	log  "  $*"
	tail -200 test_${curtest}_full.log >test_${curtest}.log
	#rm test_${curtest}_full.log
	dies=$[ $dies + 1]
      fi
    fi
  fi

  curtest=$[ $curtest + 1 ]
}

blockBUGS(){
  runTest $tool -p 1 -rp "$@" rp1.slice.fq #LOOP! FRP 
  runTest $tool -p 1 -rp "$@" cpa-symm-loop.fq #loops forever with -s 
  runTest $tool -p 1 -rp "$@" prop-simple.fq #&arp escapes!
  runTest $tool -p 1 -rp "$@" 3b.fq #UNSAT but wrong result from split-prover
}


#UNSAT if FRP is enabled, SAT otherwise
blockFRP(){
  runTest $tool -p 1 -rp "$@" copy-prop1.fq
  runTest $tool -p 1 -rp "$@" copy-prop2.fq
  runTest $tool -p 1 -rp "$@" copy-prop.fq
  runTest $tool -p 1 -rp "$@" rp1.27.fq
  runTest $tool -p 1 -rp "$@" rp1.full.fq
  runTest $tool -p 1 -rp "$@" rp3n.overflow.fq
  runTest $tool -p 1 -rp "$@" rp9.fq
  runTest $tool -p 1 -rp "$@" rp9n.fq
}

blockSYMMACSLOW(){
  runTest $tool -p 1 -rp "$@" rp1b.19.fq #slow
  runTest $tool -p 1 -rp "$@" rp4b.37.fq #slow
  runTest $tool -p 1 -rp "$@" cpa-symm-loop.fq #loops forever with -s 
}

#doesnt work if you turn off foci's store axiom x != y -> sel(store(M x _) y) = sel (M y)
blockSS(){
  runTest $tool -p 1 -rp "$@" ss5.fq
  runTest $tool -p 1 -rp "$@" ss1.fq 
  runTest $tool -p 1 -rp "$@" ss2.fq 
  runTest $tool -p 1 -rp "$@" ss3.fq 
  runTest $tool -p 1 -rp "$@" ss4-conj5.fq 
  runTest $tool -p 1 -rp "$@" ss4.fq 
  runTest $tool -p 1 -rp "$@" ss.fq 
}
  
blockSYMMAC(){
  failTest $tool -p 1 -rp "$@" cpa-symm-8-small.fq 
  failTest $tool -p 1 -rp "$@" cpa-symm-8.fq
  runTest $tool -p 1 -rp "$@" pc-full.symmcycle-cube.fq
  #runTest $tool -p 1 -rp "$@" pc-full.symmcycle.fq
  runTest $tool -p 1 -rp "$@" rp1a.27.fq
  runTest $tool -p 1 -rp "$@" rp1a.20.fq
  runTest $tool -p 1 -rp "$@" cpa-symm.fq 
  runTest $tool -p 1 -rp "$@" rp3a.20.fq 
  runTest $tool -p 1 -rp "$@" rp3b-slice1.fq 
  runTest $tool -p 1 -rp "$@" rp3b-slice1-simple.fq 
  runTest $tool -p 1 -rp "$@" copy-slice.fq
  runTest $tool -p 1 -rp "$@" rp3-slice.fq

  runTest $tool -p 1 -rp "$@" pc-full-slice2.fq
  runTest $tool -p 1 -rp "$@" pc-full-slice3.fq
  runTest $tool -p 1 -rp "$@" pc-full-slice4.fq
}

blockSYMM(){
  blockSYMMAC -s
}

#-1 reason : should go away with FRP
blockSAT(){
  failTest "SAT" $tool -p 1 -rp "$@" 001.fq
  failTest "SAT" $tool -p 1 -rp "$@" 003.fq
  failTest "SAT : Leq Reason" $tool -p 1 -rp "$@" 3.fq 
  failTest "SAT : Diseq Reason" $tool -p 1 -rp "$@" rp6.fq
  failTest "SAT : Diseq Reason" $tool -p 1 -rp "$@" rp6a.fq
#  failTest "SAT : Diseq Reason" $tool -p 1 -rp "$@" rp3a.fq
}
  
blockUNSAT(){
 runTest $tool -p 1 -rp "$@" foo.fq
 runTest $tool -p 1 -rp "$@" cpa3-short.fq 
 runTest $tool -p 1 -rp "$@" cpa3.fq 
 runTest $tool -p 1 -rp "$@" cpa4.fq 
 runTest $tool -p 1 -rp "$@" cpa4-store.fq
 runTest $tool -p 1 -rp "$@" cousot.fq 
 runTest $tool -p 1 -rp "$@" cpa.fq  
 runTest $tool -p 1 -rp "$@" rp1.fq 
 runTest $tool -p 1 -rp "$@" rp1r.fq 
 runTest $tool -p 1 -rp "$@" rp1-long.fq 
 runTest $tool -p 1 -rp "$@" rp1-flow.fq 
 runTest $tool -p 1 -rp "$@" rp1-flow-simple.fq 
 runTest $tool -p 1 -rp "$@" 01.fq 
 runTest $tool -p 1 -rp "$@" 02f.fq 
 runTest $tool -p 1 -rp "$@" 02.fq 
 runTest $tool -p 1 -rp "$@" 0.fq 
 runTest $tool -p 1 -rp "$@" 10.fq 
 runTest $tool -p 1 -rp "$@" 11.fq 
 runTest $tool -p 1 -rp "$@" 12.fq
 runTest $tool -p 1 -rp "$@" 13.fq
 runTest $tool -p 1 -rp "$@" 14.fq
 runTest $tool -p 1 -rp "$@" 15.fq
 runTest $tool -p 1 -rp "$@" 16a.fq
 runTest $tool -p 1 -rp "$@" 16.fq
 runTest $tool -p 1 -rp "$@" 17.fq
 runTest $tool -p 1 -rp "$@" 18.fq
 runTest $tool -p 1 -rp "$@" 19a.fq
 runTest $tool -p 1 -rp "$@" 19.fq
 runTest $tool -p 1 -rp "$@" 1.fq
 runTest $tool -p 1 -rp "$@" 20.fq
 runTest $tool -p 1 -rp "$@" 2.fq
 runTest $tool -p 1 -rp "$@" 3a.fq 
 runTest $tool -p 1 -rp "$@" rp6b.fq 
 runTest $tool -p 1 -rp "$@" rp7.fq 
 runTest $tool -p 1 -rp "$@" rp7-small.fq 
 runTest $tool -p 1 -rp "$@" rp8.fq 
 runTest $tool -p 1 -rp "$@" s0.fq 
 runTest $tool -p 1 -rp "$@" s1.fq 
 runTest $tool -p 1 -rp "$@" s2a.fq 
 runTest $tool -p 1 -rp "$@" s2.fq 
 runTest $tool -p 1 -rp "$@" s3.fq 
 runTest $tool -p 1 -rp "$@" simple.fq 
 runTest $tool -p 1 -rp "$@" 3rp.fq 
 runTest $tool -p 1 -rp "$@" 5.fq
 runTest $tool -p 1 -rp "$@" 6.fq
 runTest $tool -p 1 -rp "$@" 6m.fq
 #runTest $tool -p 1 -rp "$@" 7.fq #long standing FOCI BUG
 runTest $tool -p 1 -rp "$@" 8.fq
 runTest $tool -p 1 -rp "$@" 9.fq
 runTest $tool -p 1 -rp "$@" copy-prop3.fq #(UNSAT -- for wierd reasons... the root of it all...) 
 runTest $tool -p 1 -rp "$@" copy-propa.fq 
 runTest $tool -p 1 -rp "$@" rp1.14.fq 
 runTest $tool -p 1 -rp "$@" rp1a-14-smaller.fq 
 runTest $tool -p 1 -rp "$@" rp1a-14-small.fq 
 runTest $tool -p 1 -rp "$@" rp1a.21.fq 
 runTest $tool -p 1 -rp "$@" prop-simple1.fq 
 runTest $tool -p 1 -rp "$@" rp1a.6.fq 
 runTest $tool -p 1 -rp "$@" rp1a.fq 
 runTest $tool -p 1 -rp "$@" rp1b.fq  
 runTest $tool -p 1 -rp "$@" rp2.fq 
 runTest $tool -p 1 -rp "$@" rp3a.fq 
 #runTest $tool -p 1 -rp "$@" rp3a-slice.fq 
 runTest $tool -p 1 -rp "$@" rp3a.21a.fq 
 runTest $tool -p 1 -rp "$@" rp3a.21.fq 
 runTest $tool -p 1 -rp "$@" rp3a.21-simple.fq 
 runTest $tool -p 1 -rp "$@" rp3a-21-slice.fq 
 runTest $tool -p 1 -rp "$@" rp3a.slice.fq 
 runTest $tool -p 1 -rp "$@" rp3b.19.fq 
 runTest $tool -p 1 -rp "$@" rp3b-slice.fq 
 runTest $tool -p 1 -rp "$@" rp3b-slice-simple.fq 
 runTest $tool -p 1 -rp "$@" rp3.fq 
 runTest $tool -p 1 -rp "$@" rp4.fq 
 runTest $tool -p 1 -rp "$@" rp4-long.fq 
 runTest $tool -p 1 -rp "$@" rp4-long-orig.fq 
 runTest $tool -p 1 -rp "$@" rp5.fq 
 runTest $tool -p 1 -rp "$@" rp3.21.fq
 runTest $tool -p 1 -rp "$@" pc-full.81.fq
 runTest $tool -p 1 -rp "$@" pc-full.fq
 runTest $tool -p 1 -rp "$@" pc-full2.fq
 runTest $tool -p 1 -rp "$@" pc-full3.fq
 runTest $tool -p 1 -rp "$@" pc-full4.fq
 runTest $tool -p 1 -rp "$@" leq1-down.fq
}
 
blockALL(){
  blockFRP
  blockSAT
  blockUNSAT
  blockSYMMAC
  blockSYMMAC -s
  blockSYMMACSLOW 
  #blockSYMMACSLOW -s
  #blockBUGS
}

main(){
#while [ "$block" != "" ]; do
  echo $block
  case "$block" in
      FRP)
      ````shift
          blockFRP
	  ;;
      ALL)
	  shift
	  blockALL
	  ;;
      SYMMACSLOW)
          shift
	  blockSYMMACSLOW
	  ;;
      *)
      echo "unknown block $block, running all tests"
      blockALL
      #exit 2
      ;;
  esac
  
  shift
#done

# final arithmetic to report result
rm -f test.log err.log
    if [ -f "$log" ]; then
    cat "$log"
    fi
echo ""
echo "Successful tests:      $success"
echo "Failed as expected:    $failure"    
echo "Unexpected success:    $unexSuccess"
echo "Unexpected failure:    $unexFailure"
echo "No Answer:             $dies"
}

main "$1"

