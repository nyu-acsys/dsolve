\documentclass{article}
\usepackage{mathpartir}
\begin{document}

\section{Language of Types}

The language of types is described by the following grammar, where $A$ ranges over qualifier literals:

\begin{math}
\begin{array}{rcl}
\sigma & ::= & \forall \alpha . \sigma\ |\ \omega \\

\omega & ::= & \Lambda \kappa \le Q . \omega\ |\ \gamma \\

Q & ::= & \top\ |\ \bot\ |\ A \\

\gamma & ::= & \rho \eta \\

\eta & ::= & \gamma \rightarrow \gamma\ |\ \tau \\

\rho & ::= & Q\ |\ \kappa\ |\ \rho \sqcup \rho \\

\tau & ::= & \alpha\ |\ \textrm{int}\ |\ \textrm{bool} \\

\end{array}
\end{math}

We also restrict arrow types so that the first occurrence of a qualifier variable must be outside of a union, e.g., types like ${\kappa}_1 \sqcup {\kappa}_2 \tau \rightarrow {\kappa}_1 \tau$ and ${\kappa}_1 \rightarrow {\kappa}_1 \sqcup {\kappa}_2 \tau \rightarrow {\kappa}_2 \tau$ are not permitted, but types like ${\kappa}_1 \tau \rightarrow {\kappa}_2 \tau \rightarrow {\kappa}_1 \sqcup {\kappa}_2 \tau$ are.


\section{Type Checking}

The typing checking rules for System WTF are as follows, with each metavariable ranging over the types constructable from its production in the preceding grammar:

\subsection{Subtype Relation}

\begin{mathpar}

\inferrule[refl]
  { }
  {\sigma \le \sigma}

\inferrule[sub-ty]
  {\rho' \sqsubseteq \rho}
  {\rho' \tau \le \rho \tau}

\inferrule[sub-func]
  {\rho' \sqsubseteq \rho \\ {\gamma}_1' \le {\gamma}_1 \\ {\gamma}_2 \le {\gamma}_2'}
  {\rho' ({\gamma}_1' \rightarrow {\gamma}_2') \le \rho ({\gamma}_1 \rightarrow {\gamma}_2)}

\inferrule[sub-tyabs]
  {\sigma' \le \sigma}
  {\forall \alpha . \sigma' \le \forall \alpha . \sigma}

\inferrule[sub-qualabs]
  {Q \sqsubseteq Q' \\ \omega'[\kappa \mapsto Q] \le \omega[\kappa \mapsto Q] }
  {\Lambda \kappa \sqsubseteq Q' . \omega' \le \Lambda \kappa \sqsubseteq Q . \omega}

\end{mathpar}


\subsection{Annotation Rules}

The following rules are used to formalize the notion that qualifier annotation occurs underneath type and qualifier abstractions.
Note that we define $\sqcap$ such that $A \sqcap \kappa = \kappa \sqcap A = A$.

\begin{mathpar}

\inferrule[annot]
  { }
  {A \sqcap \rho \eta \hookrightarrow (A \sqcap \rho) \eta}

\inferrule[annot-tyabs]
  {A \sqcap \sigma \hookrightarrow \sigma'}
  {A \sqcap \forall \alpha . \sigma \hookrightarrow \forall \alpha . \sigma'}

\inferrule[annot-qualabs]
  {A \sqcap \omega \hookrightarrow \omega'}
  {A \sqcap \Lambda \kappa \le Q . \omega \hookrightarrow \Lambda \kappa \le Q . \omega'}

\end{mathpar}


\subsection{Typing Rules}

\begin{mathpar}

\inferrule[int]
  { }
  {\Gamma \vdash n : \textrm{int}}

\inferrule[true]
  { }
  {\Gamma \vdash \textrm{true} : \textrm{bool}}

\inferrule[false]
  { }
  {\Gamma \vdash \textrm{false} : \textrm{bool}}

\inferrule[var]
  { }
  {\Gamma \vdash x : \Gamma(x)}

\end{mathpar}


\begin{mathpar}

\inferrule[sub]
  {\Gamma \vdash e : \sigma' \\ \sigma' \le \sigma}
  {\Gamma \vdash e : \sigma}

\end{mathpar}


\begin{mathpar}

\inferrule[annot]
  {\Gamma \vdash e : \sigma \\ \Gamma \vdash A \sqcap \sigma \hookrightarrow \sigma'}
  {\Gamma \vdash [A] e : \sigma'}

\end{mathpar}


\begin{mathpar}

\inferrule[if]
  {\Gamma \vdash e_1 : \top \textrm{ bool} \\ \Gamma \vdash e_2 : \sigma \\ \Gamma \vdash e_3 : \sigma}
  {\Gamma \vdash \textrm{if } e_1 \textrm{ then } e_2 \textrm{ else } e_3 : \sigma}

\end{mathpar}


\begin{mathpar}

\inferrule[let]
  {\Gamma \vdash e' : \sigma \\ \Gamma, x:\sigma \vdash e : \gamma}
  {\Gamma \vdash \textrm{let } x : \sigma = e' \textrm{ in } e : \gamma}

\end{mathpar}


\begin{mathpar}

\inferrule[abs]
  {\Gamma,x:\gamma \vdash e : \gamma'}
  {\Gamma \vdash \textrm{fun } x : \gamma = e : \gamma \rightarrow \gamma'}

\inferrule[app]
  {\Gamma \vdash e_1 : \rho (\gamma \rightarrow \gamma') \\ \Gamma \vdash e_2 : \gamma}
  {\Gamma \vdash e_1 e_2 : \gamma'}

\end{mathpar}


\begin{mathpar}

\inferrule[tyabs]
  {\Gamma \vdash e : \sigma}
  {\Gamma \vdash \forall \alpha . e : \forall \alpha . \sigma}

\inferrule[tyapp]
  {\Gamma \vdash e : \forall \alpha . \sigma}
  {\Gamma \vdash e[\tau] : \sigma[\alpha \mapsto \tau]}

\end{mathpar}


\begin{mathpar}

\inferrule[qualabs]
  {\Gamma \vdash e : \omega}
  {\Gamma \vdash \Lambda \kappa \sqsubseteq Q . e : \Lambda \kappa \sqsubseteq Q . \omega}

\inferrule[qualapp]
  {\Gamma \vdash e : \Lambda \kappa \sqsubseteq Q . \omega \\ A \sqsubseteq Q}
  {\Gamma \vdash e\{A\} : \omega[\kappa \mapsto A]}

\end{mathpar}
Note that the rule \RefTirName{qualapp} substitutes $\kappa$ eagerly.  This is counter to what we would want in the inferred system, which is that we maintain the bound of $\kappa$ and keep track of which values it has taken, using the LUB of these values as the ``definitive'' version (i.e., the one to use in LUBs containing $\kappa$ when instantiation is complete).  However, with explicit qualifier application, it is easiest to simply instantiate $\kappa$ to this value in the first place and push aside all the tedious bookkeeping that would otherwise be required.

This difficulty suggests a different system where bounds can be either literals or variables bound by an enclosing qualifier abstraction, which sidesteps these issues entirely and could be significantly easier to reason about.

\end{document}
