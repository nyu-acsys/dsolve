mdep Myset
mdep Pervasives
const_ints 0, 1
(*Program Identifiers: a, x, y*)
qualif MLQ(_V) : (((x >= 0) and  (y >= 0)) -> ((_V >= 0) and  ((_V <= x) and  (_V <= y))))
qualif MLQ(_V) : (((x >= 0) and  (y >= 0)) -> (_V >= 0))
qualif MLQ(_V) : ((? (_V)) iff ((? (x)) and  (? (y))))
qualif MLQ(_V) : ((? (_V)) iff ((? (x)) or  (? (y))))
qualif MLQ(_V) : ((? (_V)) iff (-. (? (x))))
qualif MLQ(_V) : ((? (_V)) iff (x != y))
qualif MLQ(_V) : ((? (_V)) iff (x < y))
qualif MLQ(_V) : ((? (_V)) iff (x <= y))
qualif MLQ(_V) : ((? (_V)) iff (x = y))
qualif MLQ(_V) : ((? (_V)) iff (x > y))
qualif MLQ(_V) : ((? (_V)) iff (x >= y))
qualif Measure(_V) : ((Myset.of_list _V) = (Myset.cup (Myset.sng x) (Myset.of_list xs)))
qualif Measure(_V) : ((Myset.of_list _V) = Myset.empty)
qualif MLQ(_V) : ((x >= 0) -> (_V >= 0))
qualif MLQ(_V) : ((y > 0) -> (_V < y))
qualif MLQ(_V) : (0 <= _V)
qualif FALSE(_V) : (1 = 0)
qualif MLQ(_V) : (_V != 0)
qualif MLQ(_V) : (_V = (Myset.cap x y))
qualif MLQ(_V) : (_V = (Myset.cup x y))
qualif MLQ(_V) : (_V = (Myset.eq x y))
qualif MLQ(_V) : (_V = (Myset.mem x y))
qualif MLQ(_V) : (_V = (Myset.mns x y))
qualif Measure(_V) : (_V = (Myset.of_list a))
qualif MLQ(_V) : (_V = (Myset.of_list x))
qualif Measure(_V) : (_V = (Myset.of_list y))
qualif MLQ(_V) : (_V = (Myset.sng x))
qualif MLQ(_V) : (_V = (x * y))
qualif MLQ(_V) : (_V = (x + 1))
qualif MLQ(_V) : (_V = (x + y))
qualif MLQ(_V) : (_V = (x - (y * (x / y))))
qualif MLQ(_V) : (_V = (x - 1))
qualif MLQ(_V) : (_V = (x - y))
qualif MLQ(_V) : (_V = (x / y))
qualif MLQ(_V) : (_V >= 0)
qualif EQ(v)(A: int) : v { * * } ~A

(*sets*)
qualif V(v): ? Myset.eq (set_of v) (set_of xss)
qualif V(v): ? Myset.eq (set_of v) (Myset.of_list xs)
qualif V(v): ? Myset.eq (Myset.of_list v) (set_of xss)

qualif CON(v)(*A: int, B: 'a list*): ? Myset.eq (Myset.of_list v) (Myset.cup (Myset.sng ~A) (Myset.of_list ~B))
qualif PAR(v)(A: 'a list): ? Myset.eq (Myset.of_list ~A) (Myset.cup (Myset.of_list e0) (Myset.of_list v))
qualif APP(v)(A: 'a list, B: 'a list): ? Myset.eq (Myset.of_list v)  (Myset.cup (Myset.of_list ~A) (Myset.of_list ~B))

