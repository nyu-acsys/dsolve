#define TRUEREF [[], [v: true, v: true, v: true, v: true, v: true, v: true]]
#define R(name, rec, ref) {name: TRUEREF rec | ref}
#define U(name, rec) name: TRUEREF rec
#define TREE(rec, l, ll, d, r, lr, h) TRUEREF [rec: t . || l, ll, d, r, lr, h]

#define H(x) height x
#define L(v) length v
#define ITE(x, y, z) (x ? y : z)
#define MAX(x, y) ITE(x >= y, x, y)
#define MIN(x, y) ITE(x >= y, y, x)
#define MAXP(x, y, n) ITE(x >= y, x, y) + n
#define ISHEIGHT(e2, e3, v) ((v = MAXP(H(e2), H(e3), 1)) and v >= 0)

#define HBTWN(v, p1, p2) (H(v) >= (p1) and H(v) <= (p2))

#define ISLEN(v, e) (v = length e and v >= 0)
#define LSUMP(v, l, r, n) (L(v) = L(l) + L(r) + n)
#define LSUM(v, l, r) LSUMP(v, l, r, 0)

#define HGE0(v) (H(v) >= 0 and L(v) >= 0)
#define BALW(e2, v, n) (H(v) <= H(e2) + n and H(v) >= H(e2) - n)

#define RGDTREE(v, r) {v: TREE(z, R(e0, z, HGE0(e0)), {e1: int | ISLEN(e1, e0)}, e2: 'a, \
                               R(e3, z, BALW(e0, e3, 2) and HGE0(e3)), {e4: int | ISLEN(e4, e3)}, \
                               {e5: int | ISHEIGHT(e0, e3, e5)}) | (HGE0(v) and (r))}
#define UGDTREE RGDTREE(v, true)

measure height =
  | Empty -> 0
  | Node (_, _, _, _, _, h) -> h

measure length =
  | Empty -> 0
  | Node (_, cl, _, _, cr, _) -> 1 + cl + cr

(*
val makenode: l: UGDTREE -> 'a -> r: RGDTREE(v, BALW(l, v, 2)) -> 
  RGDTREE(v, H(v) = MAXP(H(l), H(r), 1) and L(v) = 1 + L(r) + L(l))

val create: 'a -> n: {v: int | v >= 0} -> RGDTREE(v, L(v) = n)

val bal: l: UGDTREE -> 'a -> r: RGDTREE(v, BALW(l, v, 3)) ->
  RGDTREE(v, (H(v) <= MAXP(H(l), H(r), 1) and H(v) >= MAX(H(l), H(r)) + ITE(BALW(l, r, 2), 1, 0)) and LSUMP(v, l, r, 1))
                                          
val recbal: l: UGDTREE -> 'a -> r: UGDTREE ->
  RGDTREE(v, HBTWN(v, MAX(H(l), H(r)) + ITE(BALW(l, r, 2), 1, 0-1), MAXP(H(l), H(r), 1)) and LSUMP(v, l, r, 1))

val empty: RGDTREE(v, H(v) = 0 and L(v) = 0)

val is_empty: t: UGDTREE -> {v: bool | v = (H(t) = 0 or L(t) = 0 ? 1: 0)}

val singleton: 'a -> RGDTREE(v, H(v) = 1 and L(v) = 1)

val get: i: {v: int | v >= 0} -> t: RGDTREE(v, H(v) > 0 and L(v) > i) -> 'a

val set: i: {v: int | v >= 0} -> 'a -> t: RGDTREE(v, H(v) > 0 and L(v) > i) -> RGDTREE(v, H(v) = H(t) and L(v) = L(t))
          
val append: 'a -> t: UGDTREE -> RGDTREE(v, (H(v) <= H(t) + 1 and H(t) >= H(t) - 1) and L(v) = L(t) + 1)


val setappend: 'a -> 'a -> i: {v: int | v >= 0} -> t: RGDTREE(v, HGE0(v) and L(v) > 0) -> 
  RGDTREE(v, L(v) = ITE(L(t) > i, L(t), i+1) and H(v) >= H(t))


val leftmost: t: RGDTREE(v, H(v) > 0) -> 'a
  

val remove_leftmost: t: RGDTREE(v, H(v) > 0) -> RGDTREE(v, HBTWN(v, H(t) - 1, H(t)) and L(v) = L(t) - 1)


val merge: t1: UGDTREE -> t2: RGDTREE(v, H(v) >= H(t1) - 2 and H(v) <= H(t1) + 3) -> 
  RGDTREE(v, HBTWN(v, MAX(H(t1), H(t2)), MAXP(H(t1), H(t2), 1)) and LSUM(v, t1, t2))


val concat: t1: UGDTREE -> t2: UGDTREE -> RGDTREE(v, HBTWN(v, MAX(H(t1), H(t2)) - 2, MAXP(H(t1), H(t2), 1)) and LSUM(v, t1, t2))
 

val pop: i: {v: int | v >= 0} -> t: RGDTREE(v, H(v) > 0 and L(v) > i) -> 'a * RGDTREE(v, HBTWN(v, H(t) - 1, H(t)) and L(v) = L(t) - 1)


val remove: i: {v: int | v >= 0} -> t: RGDTREE(v, H(v) > 0 and L(v) > i) -> RGDTREE(v, HBTWN(v, H(t) - 1, H(t)) and L(v) = L(t) - 1)
           

val insert: i: {v: int | v >= 0} -> 'a -> t: RGDTREE(v, L(v) >= i) -> RGDTREE(v, HBTWN(v, H(t), H(t) + 1) and L(v) = L(t) + 1)
*) 
(*
val sub: i: {v: int | v >= 0} -> j: {v: int | v >= i} ->
    t: rgdtree(v, l(v) >= 0 and l(v) > j) -> rgdtree(v, h(v) <= h(t) and l(v) = j-i)
*)
val sub: i: int -> j: int -> 
    t: UGDTREE -> RGDTREE(v, H(v) <= H(t) and L(v) = (i > j ? 0 : MIN(j, L(t)) - MAX(i, 0)))


(*
val iteri: t: UGDTREE -> ({v: int | v >= 0 and v < L(t)} -> 'a -> 'a) -> unit

val rangeiteri: t: 

*)



