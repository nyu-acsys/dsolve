mdep Pervasives
mdep Store
const_ints 0, 1
(*Program Identifiers: a, b, c, d, e, e0, e1, f, g, i, k, l, m, n, p, p', r, r', supr, x, y*)
qualif MLQ(_V) : (((Store.get p i) = i) -> (_V = i))
qualif MLQ(_V) : (((x >= 0) and  (y >= 0)) -> ((_V >= 0) and  ((_V <= x) and  (_V <= y))))
qualif MLQ(_V) : (((x >= 0) and  (y >= 0)) -> (_V >= 0))
qualif MLQ(_V) : ((? (_V)) iff ((? (x)) and  (? (y))))
qualif MLQ(_V) : ((? (_V)) iff ((? (x)) or  (? (y))))
qualif MLQ(_V) : ((? (_V)) iff (-. (? (x))))
qualif MLQ(_V) : ((? (_V)) iff (x != y))
qualif MLQ(_V) : ((? (_V)) iff (x < y))
qualif MLQ(_V) : ((? (_V)) iff (x <= y))
qualif MLQ(_V) : ((? (_V)) iff (x = y))
qualif MLQ(_V) : ((? (_V)) iff (x > y))
qualif MLQ(_V) : ((? (_V)) iff (x >= y))
qualif MLQ(_V) : ((Store.get e0 _V) = _V)
qualif MLQ(_V) : ((_V = i) or  ((Store.get e0 i) < (Store.get e0 _V)))
qualif MLQ(_V) : ((_V = i) or  ((Store.get r i) < (Store.get r _V)))
qualif MLQ(_V) : ((x >= 0) -> (_V >= 0))
qualif MLQ(_V) : ((y > 0) -> (_V < y))
qualif MLQ(_V) : (0 <= _V)
qualif FALSE(_V) : (1 = 0)
qualif MLQ(_V) : (_V != 0)
qualif MLQ(_V) : (_V < n)
qualif MLQ(_V) : (_V = (Store.get m k))
qualif MLQ(_V) : (_V = (Store.get supr i))
qualif MLQ(_V) : (_V = (Store.get supr n))
qualif MLQ(_V) : (_V = (Store.set x k l))
qualif MLQ(_V) : (_V = (x * y))
qualif MLQ(_V) : (_V = (x + 1))
qualif MLQ(_V) : (_V = (x + y))
qualif MLQ(_V) : (_V = (x - (y * (x / y))))
qualif MLQ(_V) : (_V = (x - 1))
qualif MLQ(_V) : (_V = (x - y))
qualif MLQ(_V) : (_V = (x / y))
qualif MLQ(_V) : (_V >= 0)
qualif EQ(v)  : v = ~A					(* non - spec, but generatable *)
qualif ROOT(v)(A: (int, int) Store.t): Store.get ~A v = v			(* non - spec *)
qualif BIND(v)(A: (int, int) Store.t, B: int): v = Store.get ~A ~B
qualif PRNT(v)(A: (int, int) Store.t, B: int): (v = ~B) or (Store.get ~A ~B < Store.get ~A v)
qualif PRES(v)(A: (int, int) Store.t, B: int): ((Store.get ~A ~B = ~B) -> (v = ~B))

