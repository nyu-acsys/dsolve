\documentclass{article}
\usepackage{mathpartir}
\begin{document}

\section{Language of Types}
The language of types is described by the following grammar, where $A$ ranges over qualifier literals:

\begin{math}
\begin{array}{rcl}
\sigma & ::= & \forall \alpha . \sigma\ |\ \omega \\

\omega & ::= & \Lambda \kappa \le Q . \omega\ |\ \gamma \\

Q & ::= & \top\ |\ \bot\ |\ A \\

\gamma & ::= & \rho \eta \\

\eta & ::= & \gamma \rightarrow \gamma\ |\ \tau \\

\rho & ::= & Q\ |\ \kappa\ |\ \rho \sqcup \rho\ |\ \rho \sqcap \rho \\

\tau & ::= & \alpha\ |\ \textrm{int}\ |\ \textrm{bool} \\

\end{array}
\end{math}

We also restrict arrow types so that the first occurrence of a qualifier variable must be outside of a union, e.g., types like ${\kappa}_1 \sqcup {\kappa}_2 \tau \rightarrow {\kappa}_1 \tau$ and ${\kappa}_1 \rightarrow {\kappa}_1 \sqcup {\kappa}_2 \tau \rightarrow {\kappa}_2 \tau$ are not permitted, but types like ${\kappa}_1 \tau \rightarrow {\kappa}_2 \tau \rightarrow {\kappa}_1 \sqcup {\kappa}_2 \tau$ are.
  The same restriction applies to intersection types.


\section{Expression Language}

\begin{math}
\begin{array}{rrl}

e & ::= & n \\
  & | & x \\
  & | & \textrm{true} \\
  & | & \textrm{false} \\
  & | & [ A ] e \\
  & | & \textrm{if } e \textrm{ then } e \textrm{ else } e \\
  & | & \textrm{let } x:\sigma = e \textrm{ in } e \\
  & | & \textrm{fun } x:\gamma = e \\
  & | & e e \\
  & | & \forall \alpha . e \\
  & | & e[\tau] \\
  & | & \Lambda \kappa \sqsubseteq Q . e \\
  & | & e\{A\} \\

\end{array}
\end{math}


\section{Type Checking}

The typing checking rules for System WTF are as follows, with each metavariable ranging over the types constructable from its production in the preceding grammar:

\subsection{Subtype Relation}

In the following relations, $\kappa \sqsubseteq \delta$ is understood to be undefined, though comparisons like $\kappa \sqsubseteq \kappa \sqcup \delta$ are valid.

\begin{mathpar}

\inferrule[sub-ty]
  {\rho' \sqsubseteq \rho}
  {\rho' \tau \le \rho \tau}

\inferrule[sub-func]
  {\rho' \sqsubseteq \rho \\ {\gamma}_1' \le {\gamma}_1 \\ {\gamma}_2 \le {\gamma}_2'}
  {\rho' ({\gamma}_1' \rightarrow {\gamma}_2') \le \rho ({\gamma}_1 \rightarrow {\gamma}_2)}

\inferrule[sub-tyabs]
  {\sigma' \le \sigma}
  {\forall \alpha . \sigma' \le \forall \alpha . \sigma}

\inferrule[sub-qualabs]
  {Q \sqsubseteq Q' \\ \omega'[\kappa \mapsto Q] \le \omega[\kappa \mapsto Q] }
  {\Lambda \kappa \sqsubseteq Q' . \omega' \le \Lambda \kappa \sqsubseteq Q . \omega}

\end{mathpar}


\subsection{Annotation Rules}

The following rules are used to formalize the notion that qualifier annotation occurs underneath type and qualifier abstractions.

\begin{mathpar}

\inferrule[annot]
  { }
  {A \cap \rho \eta \hookrightarrow (A \sqcap \rho) \eta}

\inferrule[annot-tyabs]
  {A \cap \sigma \hookrightarrow \sigma'}
  {A \cap \forall \alpha . \sigma \hookrightarrow \forall \alpha . \sigma'}

\inferrule[annot-qualabs]
  {A \cap \omega \hookrightarrow \omega'}
  {A \cap \Lambda \kappa \le Q . \omega \hookrightarrow \Lambda \kappa \le Q . \omega'}

\end{mathpar}


\subsection{Typing Rules}

\begin{mathpar}

\inferrule[int]
  { }
  {\Gamma \vdash n : \top \textrm{ int}}

\inferrule[true]
  { }
  {\Gamma \vdash \textrm{true} : \top \textrm{ bool}}

\inferrule[false]
  { }
  {\Gamma \vdash \textrm{false} : \top \textrm{ bool}}

\inferrule[var]
  { }
  {\Gamma \vdash x : \Gamma(x)}

\end{mathpar}


\begin{mathpar}

\inferrule[annot]
  {\Gamma \vdash e : \sigma \\ \Gamma \vdash A \sqcap \sigma \hookrightarrow \sigma'}
  {\Gamma \vdash [A] e : \sigma'}

\end{mathpar}


\begin{mathpar}

\inferrule[if]
  {\Gamma \vdash e_1 : \rho \textrm{ bool} \\ \Gamma \vdash e_2 : {\gamma}_2 \\ \Gamma \vdash e_3 : {\gamma}_3 \\ {\gamma}_2 \le \gamma \\ {\gamma}_3 \le \gamma}
  {\Gamma \vdash \textrm{if } e_1 \textrm{ then } e_2 \textrm{ else } e_3 : \gamma}

\end{mathpar}


\begin{mathpar}

\inferrule[let]
  {\Gamma \vdash e_x : \sigma_{e_{x}} \\ \Gamma[x \mapsto \sigma_x] \vdash e : \gamma \\ \sigma_{e_{x}} \le \sigma_x}
  {\Gamma \vdash \textrm{let } x : \sigma_x = e_x \textrm{ in } e : \gamma}

\end{mathpar}


\begin{mathpar}

\inferrule[abs]
  {\Gamma[x \mapsto \gamma] \vdash e : \gamma'}
  {\Gamma \vdash \textrm{fun } x : \gamma = e : \top (\gamma \rightarrow \gamma')}

\inferrule[app]
  {\Gamma \vdash e_1 : \rho (\gamma \rightarrow \gamma') \\ \Gamma \vdash e_2 : \gamma_2 \\ {\gamma}_2 \le \gamma}
  {\Gamma \vdash e_1 e_2 : \gamma'}

\end{mathpar}


\begin{mathpar}

\inferrule[tyabs]
  {\Gamma \vdash e : \sigma \\ \alpha \notin FV(\Gamma)}
  {\Gamma \vdash \forall \alpha . e : \forall \alpha . \sigma}

\inferrule[tyapp]
  {\Gamma \vdash e : \forall \alpha . \sigma}
  {\Gamma \vdash e[\gamma] : \sigma[\alpha \mapsto \gamma]}

\end{mathpar}


\begin{mathpar}

\inferrule[qualabs]
  {\Gamma \vdash e : \omega \\ \kappa \notin FV(\Gamma)}
  {\Gamma \vdash \Lambda \kappa \sqsubseteq Q . e : \Lambda \kappa \sqsubseteq Q . \omega}

\inferrule[qualapp]
  {\Gamma \vdash e : \Lambda \kappa \sqsubseteq Q . \omega \\ A \sqsubseteq Q}
  {\Gamma \vdash e\{A\} : \omega[\kappa \mapsto A]}

\end{mathpar}


\section{Type Inference}

As before, annotation occurs underneath qualifiers.


\subsection{Type Unions and Intersections}


\subsection{Inference Rules}

\begin{mathpar}

\inferrule[int]
  { }
  {\Gamma \vdash n : \top \textrm{ int}}

\inferrule[true]
  { }
  {\Gamma \vdash \textrm{true} : \top \textrm{ bool}}

\inferrule[false]
  { }
  {\Gamma \vdash \textrm{false} : \top \textrm{ bool}}

\inferrule[var]
  { }
  {\Gamma \vdash x : \Gamma(x)}

\end{mathpar}


\begin{mathpar}

\inferrule[annot]
  {\Gamma \vdash e : \sigma \\ A \cap \sigma \hookrightarrow \sigma'}
  {\Gamma \vdash [A] e : \sigma'}

\end{mathpar}


\begin{mathpar}

\inferrule[if]
  {\Gamma \vdash e_1 : \rho \textrm{ bool} \\ \Gamma \vdash e_2 : \gamma_2 \\ \Gamma \vdash e_3 : \gamma_3}
  {\Gamma \vdash \textrm{if } e_1 \textrm{ then } e_2 \textrm{ else } e_3 : \gamma_2 \cup \gamma_3}

\end{mathpar}


\begin{mathpar}

\inferrule[let]
  {\Gamma \vdash e_x : \sigma_{e_{x}} \\ \Gamma[x \mapsto \sigma_{e_{x}}] \vdash e : \gamma}
  {\Gamma \vdash \textrm{let } x = e_x \textrm{ in } e : \gamma}

\end{mathpar}


\begin{mathpar}

\inferrule[abs]
  {\Gamma[x \mapsto \gamma] \vdash e : \gamma'}
  {\Gamma \vdash \textrm{fun } x = e : \top (\gamma \rightarrow \gamma')}

\inferrule[app]
  {\Gamma \vdash e_1 : \rho (\gamma \rightarrow \gamma') \\ \Gamma \vdash e_2 : \gamma_2 \\ \gamma_2 \le \gamma}
  {\Gamma \vdash e_1 e_2 : \gamma'}

\end{mathpar}


\begin{mathpar}

\inferrule[t-gen]
  {\Gamma \vdash e : \sigma \\ \alpha \notin FV(\Gamma)}
  {\Gamma \vdash e : \forall \alpha. \sigma}

\inferrule[t-inst]
  {\Gamma \vdash e : \forall \alpha.\sigma}
  {\Gamma \vdash e : \sigma[\alpha \mapsto \gamma]}

\end{mathpar}


\begin{mathpar}

\inferrule[q-gen]
  {\Gamma \vdash e : \omega \\ \kappa \notin FV(\Gamma)}
  {\Gamma \vdash e : \Lambda \kappa \le Q. \omega}

\inferrule[q-inst]
  {\Gamma \vdash e : \Lambda \kappa \le Q. \omega \\ A \sqsubseteq Q}
  {\Gamma \vdash e : \omega[\kappa \mapsto A]}

\end{mathpar}


\end{document}
